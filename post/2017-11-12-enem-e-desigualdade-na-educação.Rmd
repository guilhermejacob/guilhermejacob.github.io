---
title: "ENEM e desigualdade na educação: uma análise dos dados de 2015"
author: ~
date: '2017-11-15'
slug: enem-desigualdade-educação
categories: ["R" , "Public Records" ]
tags: [ "Children's Rights" , "Rstats" , "DataViz" , "Brazil" , "Education" , "Inequality" ]
bibliography: [enem-post.bib]
csl: associacao-brasileira-de-normas-tecnicas-ipea.csl
# languageCode: "pt-br"
draft: false
---

Há alguns dias atrás, rolou o ENEM desse ano. E daí veio a ideia para este post: analisar a desigualdade na educação entre os jovens do Ensino Médio a partir das pontuações dos candidatos. Usando R, como sempre.

Vou tentar manter as complicações matemáticas fora da questão e focar na aplicação da técnica para entender o contexto da desigualdade educacional. Assim, pretendo trazer gente de outras áreas, como pedagogos e sociólogos, que podem se beneficiar de mais uma ferramenta para analisar o problema, além de contribuir com novas perspectivas para "aqueles que só pensam com números"^[Já me chamaram de coisa pior.].

E, sim, hoje vai ser tudo em português.

Pegue seu café, sente-se confortavelmente e vamos lá!

## ENEM

O *Exame Nacional do Ensino Médio (ENEM)* é uma prova realizada anualmente pelo *Instituto Nacional de Estudos e Pesquisas Educacionais Anísio Teixeira (INEP)*, um órgão associado ao Ministério da Educação. A finalidade do ENEM é avaliar a qualidade do ensino médio e, **desde 2009**, tornou-se a principal forma de ingresso nas universidades públicas do Brasil. De fato, esse é o segundo maior vestibular do mundo, ficando atrás apenas do exame de admissão chinês.

Embora a prova exista desde 1998, foi com o estabelecimento do SiSU que o número de examinados cresceu. Assim, o exame, antes composto majoritariamente por estudantes de escolas públicas, passou a ser amplamente utilizada pelos de escolas particulares. Essa mudança proporciona um experimento interessante sobre o desempenho dos estudantes do Brasil.

## Desigualdade e educação

```{r info_tag, echo=FALSE, message=FALSE, warning=FALSE}
htmltools::HTML("{{< alert info >}}
Essa parte contém um pouco de matemática.<br>Mas, não se assuste: vou <del>tentar</del> explicar tudo sem muita complicação.
{{< /alert >}}")
```

O estudo da desigualdade é uma mistura de economia, filosofia, matemática e estatística. Embora os estudos neste campo se voltem majoritariamente às distribuições de renda e riqueza, existem vários trabalhos discutindo outras formas de desigualdade. 

No entanto, o tipo de variável costuma ser o principal desafio: renda é uma variável contínua, enquanto o estado de saúde, por exemplo, costuma ser uma variável ordinal. Esse tipo de problema é comum na análise de aspectos qualitativos do bem-estar. Em outras palavras, quando perguntadas a respeito de sua saúde, as pessoas não respondem "estou com 75 de saúde" ~~a não ser que você esteja jogando LOL ou algo do tipo~~, mas algo como "ruim" , "bem", "excelente". Quando temos esse tipo de resposta, não dá pra simplesmente calcular um índice de Gini. Caso você se interesse por esses problemas, @cowell2017 é uma leitura obrigatória, mostrando como as medidas tradicionais falham e propondo uma classe de medidas que atende os axiomas propostos.

Dito isso, cabe a pergunta: existe uma medida cardinal da desigualdade em educação? Se considerarmos o desempenho dos alunos em provas, pode-se dizer que sim. A lógica é mais ou menos essa: quanto mais preparado o aluno, melhor o desempenho na prova. Se o desempenho é medido em pontuação *e não em categorias*, podemos usar a pontuação para medir a desigualdade.

Evidentemente, essa abordagem tem seus problemas, desde provas mal formuladas a seleção de alunos examinados. Esse último é particularmente sério. Como a média das notas de uma escola é tomada como uma indicação da qualidade do seu ensino, um diretor mais mal intencionado pode dificultar a candidatura dos alunos que teriam uma pontuação ruim. Desta forma, a amostra se torna viesada. Isso é mais possível em escolas particulares, já que é mais provável que os alunos tenham condições financeiras de ir para uma faculdade particular.

A própria percepção do diferencial de desempenho entre escolas públicas e particulares pode ser causar um viés na amostra. O aluno que pensa não ter chance no vestibular não tem muito incentivo para fazer a prova. Existe uma miríade de aspectos socioeconômicos que fazem com que esse comportamento ocorra.

Com essas ressalvas em mente, prossigamos.

## Algumas estatísticas sobre o ENEM 2015

Para entender um pouco de como se distribuem resultados, vamos analisar quem são os 1000 melhores e os 1000 piores de acordo com o desempenho nas provas. No exercício a seguir, analisaremos apenas os dados dos alunos que: 

* Estavam concluindo o ensino médio em 2015, e
* Estiveram presentes em todas as provas, e
* Não tiveram qualquer problema na redação, e
* Não estavam fazendo a prova apenas para medir seus conhecimentos.

Só para confirmar: estamos trabalhando com a *interseção* destes quatro conjuntos de examinados, *não a união*.

```{r coleta_dados, message=FALSE, warning=FALSE, cache=TRUE, include=FALSE}
# link para base de dados:
library(DBI)
library(MonetDBLite)

dbfolder <- "~/Bases/ENEM/MonetDB"

# conecta à base de dados
db <- dbConnect( MonetDBLite() , dbfolder )

# cria identificador
if ( !( "id_inscricao" %in% dbListFields( db , "enem2015" ) ) ) {
  dbSendQuery( db , "ALTER TABLE enem2015 ADD id_inscricao STRING ")
  dbSendQuery( db , "UPDATE enem2015 SET id_inscricao = CAST( CAST( nu_inscricao AS BIGINT ) AS STRING ) ")
}
# dbGetQuery( db , "SELECT id_inscricao FROM enem2015 limit 10 ") # testa resultado

# restringe casos
subset_string <- "WHERE ( tp_st_conclusao = 2 )"
subset_string <- paste( subset_string , "AND ( tp_presenca_cn = 1 AND tp_presenca_ch = 1 AND tp_presenca_lc = 1 AND tp_presenca_mt = 1 )" )
subset_string <- paste( subset_string , "AND ( tp_status_redacao = 1 )" )
subset_string <- paste( subset_string , "AND ( in_treineiro = 0 )" )

# lista variaveis
variaveis <- dbListFields( db , "enem2015" )

# pega variaveis de nota
notas <- variaveis [ grep( "nu_nota" , variaveis ) ]

# remove componentes da prova de redação:
notas <- notas [ -grep( "comp" , notas ) ]

# cria SELECT query com variável desempenho
# desempenho_sql <- paste0( "( " , paste0( notas , collapse = " + " ) , " ) / 5 AS desempenho" )



# cria view com essa distribuição
# dbSendQuery( db , paste( "CREATE VIEW enem_data AS SELECT *," , desempenho_sql , "FROM enem2015" , subset_string , "ORDER BY desempenho" ) )

# cria tabela com essa distribuição e inner join com tabela-consistência
subset_string <- "WHERE ( a.tp_st_conclusao = 2 )"
subset_string <- paste( subset_string , "AND ( a.tp_presenca_cn = 1 AND a.tp_presenca_ch = 1 AND a.tp_presenca_lc = 1 AND a.tp_presenca_mt = 1 )" )
subset_string <- paste( subset_string , "AND ( a.tp_status_redacao = 1 )" )
subset_string <- paste( subset_string , "AND ( a.in_treineiro = 0 )" )
dbSendQuery( db , paste( "CREATE TABLE enem_data AS SELECT a.* FROM enem2015 AS a INNER JOIN consistencia_enem_escola_2015 as b ON a.nu_inscricao = b.nu_inscricao" , subset_string  ) )
desempenho_sql <- paste0( "( " , paste0( notas , collapse = " + " ) , " ) / 5" )
dbSendQuery( db , "ALTER TABLE enem_data ADD desempenho REAL" )
dbSendQuery( db , paste( "UPDATE enem_data SET desempenho =" , desempenho_sql ) )

# coleta os 1000 melhores
upper_part <- dbGetQuery( db , "SELECT * FROM enem_data ORDER BY desempenho DESC LIMIT 1000" )
# coleta os 1000 piores
lower_part <- dbGetQuery( db , "SELECT * FROM enem_data ORDER BY desempenho ASC LIMIT 1000" )

# descarta view
# dbSendQuery( db , "DROP VIEW enem_data" )

# descarta tabela
# dbSendQuery( db , "DROP TABLE enem_data" )

# disconecta da base
dbDisconnect( db , shutdown = TRUE )

# mantém apenas objetos úteis
rm( list = grep( "^(upper|lower)_" , ls() , value = TRUE , invert = TRUE ) )

```

O gráfico \ref{dist_extreme} abaixo mostra como as notas dos extremos se distribuem. Enquanto os melhores desempenhos tendem a se concentrar mais entre domicílios mais ricos, os piores desempenhos se concentram ainda mais entre os domicílios mais pobres. Ou seja, é bem mais provável que uma "nota baixa" venha de um domicílio de baixa renda. O "monte" em vermelho entre os domicílios de catagoria "B" e "C" mostra isso. E a queda se comparado a categoria "A" se deve principalmente a raridade destes indivíduos, seja porque realmente existem poucos domicílios com nenhuma renda, seja porque as pessoas destes domicílios tendem a não fazer a prova.

```{r dist_extreme, echo=FALSE, message=FALSE, warning=FALSE , cache = FALSE } 
# remove caracteres especiais
upper_part[ , grep( "^no_" , colnames(upper_part) , value = TRUE ) ] <- apply( upper_part[ , grep( "^no_" , colnames(upper_part) , value = TRUE ) ] , 2 , function(x) gsub( "'|\\^|~" , "" , x ) )
lower_part[ , grep( "^no_" , colnames(lower_part) , value = TRUE ) ] <- apply( lower_part[ , grep( "^no_" , colnames(lower_part) , value = TRUE ) ] , 2 , function(x) gsub( "'|\\^|~" , "" , x ) )

upper_part$marcador <- "Melhores"
lower_part$marcador <- "Piores"

# densidade
library(ggplot2)
library(ggiraph)

stacked_data <- rbind( upper_part , lower_part )

dist_extreme <- ggplot(stacked_data, aes( x = q006 , group = marcador , fill = marcador )) +
  geom_density(adjust = 5 , color = "transparent" , alpha = .7 ) +
  # geom_histogram( aes( color = marcador ) , adjust = 5 , alpha = .7 , stat = "density" ) +
  scale_fill_manual( values = c( "Piores" = "red" , "Melhores" = "blue" ) ) +
  guides(fill = guide_legend(title = "Situação", title.position = "top") ) +
  scale_y_continuous( labels = scales::percent ) +
  coord_cartesian( ylim = c( 0,.4 ) ) +
  labs( x = "Classes" , y = "Densidade", 
        title = "Distribuição da pontuação por classe de renda domiciliar." , 
        subtitle ="Classes de renda distribuídas em ordem crescente." ,
        caption = "Fonte: ENEM 2015. Microdados.") +
  theme( panel.grid.major.y = element_line( colour = "grey" , linetype = 3 ) ,  
         # panel.grid.major.y = element_blank() , 
         panel.background = element_rect( fill = "white" ) , 
         panel.grid.minor.x = element_blank() ,
         panel.grid.major.x = element_blank() , 
         plot.title = element_text(lineheight=.8, face="bold") )

dist_extreme
# ggiraph( code = {print(dist_extreme)} , zoom_max = 5 , width = 1 , tooltip_opacity = .7 , width_svg = 8, height_svg = 5 , dep_dir = "/Users/guilhermejacob/Documents/GitLab/src-website/blogdown/post" )
```

Ok, mas e as médias? A média da pontuação dos extremos é bem diferente, como de se esperar. De fato, a pontuação dos melhores é aproximadamente 2.7 vezes melhor que a dos piores. O gráfico \ref{avg_extreme} abaixo mostra esta discrepâncias.
```{r avg_extreme, echo=FALSE, message=FALSE, warning=FALSE , cache = FALSE } 

library(dplyr)
media_desempenho <- stacked_data %>%  group_by( marcador ) %>% summarise( media = mean( desempenho ) )
media_desempenho$marcador <- factor( media_desempenho$marcador , levels = c( "Piores" , "Melhores" ) )

dist_media <- ggplot(media_desempenho, aes( x = marcador , y = media , group = marcador , fill = marcador ) ) +
  # geom_bar( stat = "identity" , width = .5 , alpha = .7 ) +
  geom_bar_interactive( stat = "identity" , width = .5 , alpha = .7 , show.legend = TRUE ) +
  scale_fill_manual( values = c( "Piores" = "red" , "Melhores" = "blue" ) ) +
  guides(fill = FALSE ) +
  scale_x_discrete( labels = c( "Piores" = "1000\nPiores" , "Melhores" = "1000\nMelhores" ) ) +
  coord_cartesian( ylim = c( 0, 1000 ) ) +
  labs( x = "Situação" , y = "Pontuação", 
        title = "Média da pontuação dos 1000 piores e 1000 melhores." , 
        # subtitle ="Classes de renda distribuídas em ordem crescente." ,
        caption = "Fonte: ENEM 2015. Microdados.") +
  theme( panel.grid.major.y = element_line( colour = "grey" , linetype = 3 ) ,  
         # panel.grid.major.y = element_blank() , 
         panel.background = element_rect( fill = "white" ) , 
         panel.grid.minor.x = element_blank() ,
         panel.grid.major.x = element_blank() , 
         plot.title = element_text(lineheight=.8, face="bold") )

dist_media
# ggiraph( code = { print( dist_media ) } , zoom_max = 1 , width = 1 , tooltip_opacity = .7 , width_svg = 8, height_svg = 5 , dep_dir = "/Users/guilhermejacob/Documents/GitLab/src-website/blogdown/post" )
```

## Como medir: um exercício de decomposição por subgrupos.

Se você já leu alguma coisa sobre desigualdade, você deve ter visto estimativas do índice de Gini. Essa é, de longe, a medida de desigualdade mais conhecida. Mas também existem outras medidas bem interessantes. Uma medida recente é a J-divergência, proposta por @rohde2016. Ela tem uma vantagem sobre o índice de Gini: decomposição por subgrupos. I.e., a estimativa pode mostrar o quanto se deve a desigualdade entre grupos e intra-grupos.

As duas medidas estão disponíveis no pacote `convey` [@convey], incluindo a decomposição da J-divergência. Facilmente encontradas em @context, as fórmulas dos indicadores são essas:

$$
\begin{aligned}
G &= 1 - 2 \int_{0}^{1} L(p)dp \\
J &= \int_{0}^{\infty} \bigg( \frac{ y_i - \mu }{ \mu } \bigg) \log \bigg( \frac{y_i}{\mu} \bigg) f \big( y_i \big) dy
\end{aligned}
$$
onde $L(\cdot)$ é a curva de Lorenz.

~~Nota: talvez eu devesse parar com o marketing pessoal.~~

## Na prática

Vamos usar os dados do ENEM 2015, disponíveis na [página de microdados do INEP](http://portal.inep.gov.br/web/guest/microdados). Depois de colocar os dados numa base MonetDB, vou criar um "pseudo-desenho amostral". Por que "pseudo"? Porque a base não é uma amostra propriamente dita. Então, por que fazer isso? As funções do `convey` só funcionam sobre objetos de desenho amostral. Além disso, o `convey` funciona bem com bases de dados externas, usando apenas as informações necessárias para o cálculo.
```{r estima_desigualdade, echo=FALSE, message=FALSE, warning=FALSE , cache = TRUE , include = FALSE }
library(DBI)
library(MonetDBLite)
library(survey)
library(convey)

# link para base de dados:
dbfolder <- "~/Bases/ENEM/MonetDB"

# cria objeto de desenho amostral
enem_design <- svydesign( ids = ~0 , data = 'enem_data' , weights = ~1 , dbtype = "MonetDBLite" , dbname = dbfolder )

# restringe para subpopulação que está cursando o ensino médio e conclui em 2015:
enem_design <- subset( enem_design , tp_st_conclusao == 2 )

# restringe para presentes em todas as provas
enem_design <- subset( enem_design , tp_presenca_cn == 1 & tp_presenca_ch == 1 & tp_presenca_lc == 1 & tp_presenca_mt == 1 )

# restringe para pessoas que fizeram a redação "sem problemas"
enem_design <- subset( enem_design , tp_status_redacao == 1 )

# restringe para não-treineiros
enem_design <- subset( enem_design , in_treineiro == 0 )

# cria variável nota final:
# enem_design <- update( enem_design , desempenho = nu_nota_cn + nu_nota_ch + nu_nota_lc + nu_nota_mt + nu_nota_redacao )

# cria variável região de residência:
enem_design <- update( enem_design , co_rg_residencia = substr( co_uf_residencia  , 1 , 1 ) )
enem_design <- update( enem_design , co_rg_esc = substr( co_uf_esc  , 1 , 1 ) )

# transforma para objeto convey:
suppressWarnings( enem_design <- convey_prep( enem_design ) )

# calcula médias:
br_medias <- svymean( ~desempenho + nu_nota_cn + nu_nota_ch + nu_nota_lc + nu_nota_mt + nu_nota_redacao , enem_design , na.rm = TRUE )
pp_medias <- svyby( ~desempenho + nu_nota_cn + nu_nota_ch + nu_nota_lc + nu_nota_mt + nu_nota_redacao , ~tp_dependencia_adm_esc , enem_design , svymean , na.rm = TRUE )
rd_medias <- svyby( ~desempenho + nu_nota_cn + nu_nota_ch + nu_nota_lc + nu_nota_mt + nu_nota_redacao , ~q006 , enem_design , svymean , na.rm = TRUE )

# calcula gini
br_gini <- svygini( ~desempenho , enem_design , na.rm = TRUE )
pp_gini <- svyby( ~desempenho , ~tp_dependencia_adm_esc , enem_design , svygini , na.rm = TRUE )
rg_gini <- svyby( ~desempenho , ~co_rg_esc , enem_design , svygini , na.rm = TRUE )
rd_gini <- svyby( ~desempenho , ~q006 , enem_design , svygini , na.rm = TRUE )

# calcula j-divergência
br_jdiv <- svyjdiv( ~desempenho , enem_design , na.rm = TRUE )
pp_jdiv <- svyby( ~desempenho , ~tp_dependencia_adm_esc , enem_design , svyjdiv , na.rm = TRUE )
rg_jdiv <- svyby( ~desempenho , ~co_rg_esc , enem_design , svyjdiv , na.rm = TRUE )
rd_jdiv <- svyby( ~desempenho , ~q006 , enem_design , svyjdiv , na.rm = TRUE )

# calcula decomposição da j-div
br_jdiv_adm <- svyjdivdec( ~desempenho , ~tp_dependencia_adm_esc , enem_design , na.rm = TRUE )
br_jdiv_rnd <- svyjdivdec( ~desempenho , ~q006 , enem_design , na.rm = TRUE )
br_jdiv_cor <- svyjdivdec( ~desempenho , ~tp_cor_raca , enem_design , na.rm = TRUE )
br_jdiv_gnr <- svyjdivdec( ~desempenho , ~tp_sexo , enem_design , na.rm = TRUE )

# descarta tabela
dbSendQuery( enem_design$db$connection , "DROP TABLE enem_data" )

# desconecta da base:
close( enem_design , shutdown = TRUE )

# remove objeto do desenho
rm( enem_design )

# mantém apenas objetos úteis
rm( list = grep( "^(br|pp|rg|rd)_" , ls() , value = TRUE , invert = TRUE ) )

```
```{r tabela1, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE }
library(knitr)
tabela1 <- data.frame( 
    Área = c( "Brasil" , "Norte" , "Nordeste" , "Sudeste" , "Sul" , "Centro-Oeste") , 
    Gini = round( c( coef( br_gini ) , coef( rg_gini ) ) , 4 ) , 
    `J-divergência` = round( c( coef( br_jdiv ) , coef( rg_jdiv ) ) , 4 ) )
kable( tabela1 , col.names = c( "Área" , "Gini" , "J-divergência" ) , row.names = F , format.args = list(decimal.mark = ".", big.mark = " ") )
```

As primeiras coisas que percebemos ao olhar a tabela \ref{tabela1} são: (1) existe menos desigualdade nesta distribuição do que em distribuições de renda, e (2) o índice de Gini é maior que a J-divergência. A primeira observação decorre de um aspecto um tanto óbvio: as pontuações tem um limite superior, ao contrário das distribuições de renda. Em outras palavras, uma pessoa não pode ter mais do que 1 000 pontos, embora sua renda pode extrapolar esse limite. O segundo aspecto também é interessante: o índice de Gini é mais sensível às desigualdades próximas da média, enquanto a J-divergência tende a ser mais sensível às desigualdades nas caudas. Consequentemente, podemos supor que a maior parte da desigualdade está no meio da distribuição.

É normal que a diferença entre categorias apresente um valor menor que a desigualdade dentro das categorias, mesmo para renda. Dito isso, a decomposição da J-divergência, na tabela \ref{tabela2} abaixo, mostra alguns padrões interessantes. ~~Apesar de todo retrocesso recente,~~ A desigualdade no desempenho entre os gêneros^[Peço que me corrijam se eu estiver usando o termo incorretamente!] praticamente não se deve a este aspecto. A decomposição captou impactos das diferenças entre cor/raça, embora esses sejam menores que os impactos decorrentes do tipo de escola^[Aqui, tipo de escola se refere à dependência administrativa.] ou da renda. No caso da renda, 30% da desigualdade pode ser atribuída à desigualdade entre as classes.
```{r tabela2, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE }
tabela2 <- rbind( coef( br_jdiv_rnd ) , coef( br_jdiv_adm ) , coef( br_jdiv_cor ) , coef( br_jdiv_gnr ) )
tabela2 <- data.frame( tabela2 , row.names = c( "Renda" , "Tipo de Escola" , "Cor/Raça" , "Gênero" ) )
tabela2 <- tabela2[ order( tabela2$between ) , ]
# tabela2[ , 2:3 ] <- tabela2[ , 2:3 ] / tabela2[ , 1 ] # normalize
tabela2 <- round( tabela2 , 4 )

kable( tabela2 , col.names = c( "J-divergência" , "Entre" , "Intra" ) , row.names = TRUE , format.args = list(decimal.mark = ".", big.mark = " ") , caption = "Decomposição da J-divergência - Brasil, 2015" )
```

### Concluindo

Com esse exercício, quis mostrar que, embora os indicadores de desigualdade sejam normalmente associados às distribuições de renda, eles podem ser aplicados a outras distribuições. No caso, eles podem ajudar a entender aspectos da desigualdade na educação, desde que aplicados corretamente.

No entanto, o problema da desigualdade com variáveis ordinais continua aberto. Ainda não existem muitos trabalhos a respeito de inferência estatística com este tipo de medida. Deixo aqui uma possível cena dos próximos capítulos: será que podemos calcular *desigualdade em saúde* usando a Pesquisa Nacional de Saúde levando em consideração o desenho amostral complexo? 

*Peut être.*

## Referências
