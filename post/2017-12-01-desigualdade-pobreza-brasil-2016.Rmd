---
title: "O que a PNAD Contínua 2016 diz sobre desigualdade e pobreza nos estados?"
author: ~
date: '2017-12-03'
slug: desigualdade-pobreza-estados-2016
categories: [ "R" , "Complex Survey" , "Official Statistics" ]
tags: [ "Poverty" , "Inequality" , "Brazil" ]
draft: false
---

```{r setup_session, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(cache=TRUE) # defaults to cacheing
```

<!--html_preserve-->
{{< alert warning >}}
<b>Atualização (19/05/2018):</b> corrigi alguns erros no código que afetavam as estimativas das capitais.<br>
Já que os intervalos de confiança das estimativas de capitais não permitiam uma análise mais profunda, resolvi mudar para análise das UFs.<br>
As rendas foram ajustadas para preços médios de 2016.
{{< /alert >}}
<!--/html_preserve-->

Na última quarta (29/11), o IBGE ~~finalmente~~ apresentou as estimativas relativas aos rendimentos de todas as fontes, além de disponibilizar os microdados para os cálculos.

*Ok, mas o que isso quer dizer?* Aguardei ansiosamente^[Eu + ansiedade é, praticamente, [pleonasmo](https://pt.wikipedia.org/wiki/Pleonasmo).] para saber como as coisas irão funcionar com o fim da *PNAD* ~~anual~~ e introdução da *PNAD Contínua*.  
Antes, a PNAD trazia informações referentes ao ano. Agora, a PNAD Contínua traz informações sobre os trimestres. E quanto às informações anuais?  
Bom, isso acaba de ser respondido.

Dito isso, vamos às estimativas^[Todas as estimativas foram realizadas utilizando a *library* [`convey`](https://cran.r-project.org/web/packages/convey/index.html).].

### Desigualdade

Eu tinha certa curiosidade a respeito do quanto as novas variáveis de renda diferenciam das antigas quando se trata de desigualdade. Essa dúvida não foi completamente respondida, já que os dados concomitantes de rendimento da PNAD Contínua e PNAD anual ainda não são estão disponíveis. Mas já podemos ter alguns números.

<!--html_preserve-->
{{< alert warning >}}
Todos as estimativas a seguir foram feitas por mim.<br>Assim, nem IBGE, nem qualquer outra instituição tem nada a ver com os meus comentários ou conclusões. **Ou seja: nada aqui é definitivo**.
{{< /alert >}}
<!--/html_preserve-->

##### Índice de Gini

```{r database_setup, message=FALSE, warning=FALSE, include=FALSE , cache=FALSE }
# tentativa de replicar números da publicação:
# https://biblioteca.ibge.gov.br/visualizacao/livros/liv101390.pdf

library(downloader)

# define diretórios
output_dir <- "~/Bases/PNAD Contínua/Anual/Dados"

# set uf table
uf <-
  structure(list(V1 = c(11L, 12L, 13L, 14L, 15L, 16L, 17L, 21L, 
                        22L, 23L, 24L, 25L, 26L, 27L, 28L, 29L, 31L, 32L, 33L, 35L, 41L, 
                        42L, 43L, 50L, 51L, 52L, 53L), 
                 V2 = structure(c(22L, 1L, 4L, 
                                  23L, 14L, 3L, 27L, 10L, 18L, 6L, 20L, 15L, 17L, 2L, 26L, 5L, 
                                  13L, 8L, 19L, 25L, 16L, 24L, 21L, 12L, 11L, 9L, 7L), 
                                .Label = c("Acre", "Alagoas", "Amapá", "Amazonas", "Bahia", "Ceará", "Distrito Federal", 
                                           "Espírito Santo", "Goiás", "Maranhão", "Mato Grosso", "Mato Grosso do Sul", 
                                           "Minas Gerais", "Pará", "Paraíba", "Paraná", "Pernambuco", "Piauí", 
                                           "Rio de Janeiro", "Rio Grande do Norte", "Rio Grande do Sul", 
                                           "Rondônia", "Roraima", "Santa Catarina", "São Paulo", "Sergipe", 
                                           "Tocantins"), class = "factor")), .Names = c("uf", "uf_name"), 
            class = "data.frame", row.names = c(NA, -27L))
uf$cp_name <- c("Porto Velho" , "Rio Branco" , "Manaus", "Boa Vista", "Belém", "Macapá", "Palmas", "São Luís", "Teresina", 
                "Fortaleza" , "Natal", "João Pessoa" , "Recife" , "Maceió" , "Aracaju", "Salvador", "Belo Horizonte" , 
                "Vitória" , "Rio de Janeiro", "São Paulo" , "Curitiba", "Florianópolis" , "Porto Alegre", "Campo Grande", 
                "Cuiabá", "Goiânia" , "Brasília" )
uf$rg_name <- factor( substr( uf$uf , 1 , 1 ) , levels = 1:5 , labels = c( "Norte" , "Nordeste" , "Sudeste" , "Sul" , "Centro-Oeste" ) )




# monta tabela com deflatores
# faz download da tabela
tf <- tempfile()
download.file( "ftp://ftp.ibge.gov.br/Trabalho_e_Rendimento/Pesquisa_Nacional_por_Amostra_de_Domicilios_continua/Anual/Microdados/Documentacao/deflator_2017_pnadc.xls" , tf )

# lê arquivo do excel
deflat_tab <- readxl::read_xls( tf , sheet = 1 )

# ajusta nomes
colnames( deflat_tab ) <- tolower( colnames( deflat_tab ) )
colnames( deflat_tab )[ colnames( deflat_tab ) %in% "trim" ] <- "trimestre"

# transforma para preços médios de 2017:
mid_year_price <- lapply( split( deflat_tab[ , c(1:3,6)] , f = list( deflat_tab$ano , deflat_tab$uf ) ) , function (x) { data.frame( ano = x[ 1 , 1 ] , uf = x[ 1 , 3 ] , deflt = sum( x[ , 2:3 ] )/4 ) } )
mid_year_price <- do.call( rbind , mid_year_price )
mid_year_price <- lapply( split( mid_year_price , f = list( mid_year_price$uf ) ) , function (x) { x[ , "ratio" ] <- x[ , "deflt" ] / x[ x$ano == 2016 , "deflt" ] ; x[ , c(1:2,4) ] })
mid_year_price <- do.call( rbind , mid_year_price )

# prepara deflator
deflat_tab <- merge( deflat_tab , mid_year_price , by = c( "ano" , "uf" ) )
deflat_tab$deflt <- deflat_tab$co1 / deflat_tab$ratio

# formata tabela
deflat_tab <- deflat_tab[ , c( "ano" , "trimestre" , "uf" , "deflt" ) ]


# monta desenho amostral
# carrega os pacotes necessários
library(fst)
library( survey )
library( convey )
options( survey.lonely.psu = "adjust" )
options( survey.multicore = TRUE )

# list files
these_designs <- list.files( output_dir , full.names = TRUE )

these_designs <- these_designs[ grepl( "2016 1" , these_designs ) ]

this_file <- these_designs[[1]]

# read dataset
these_columns <- c( "upa" , "estrato" , "v1031" , "v1030" , "posest" , "ano" , "trimestre" , "uf" , "capital" , "v2010" , "v2009" , "vd4016" , paste0( "vd500" , 1:6 ) , "v3002" , paste0( "vd402" , c(0,2) ) , "vd2002" , "v20082" )
pnadc_df <- read_fst( this_file , columns = these_columns )

# merge data
pnadc_df <- merge( pnadc_df , uf , by = "uf" )

# fix cp_name
pnadc_df$cp_name <- ifelse( !is.na( pnadc_df$capital ) , pnadc_df$cp_name , NA )

# add one column
pnadc_df$one <- 1

# create region
pnadc_df$regiao <- substr( pnadc_df$uf , 1 , 1 )

# combina deflator
pnadc_df <- merge( pnadc_df , deflat_tab , by = c( "ano" , "trimestre" , "uf" ) , all.x = TRUE , all.y = FALSE )

# deflaciona os rendas
pnadc_df[ , paste0( "def_" , paste0( "vd500" , c(1:2,4:5) ) ) ] <- ( pnadc_df[ , paste0( "vd500" , c(1:2,4:5) ) ] * pnadc_df$deflt )
pnadc_df[ , paste0( "def_" , paste0( "vd402" , c(0,2) ) ) ] <- ( pnadc_df[ , paste0( "vd402" , c(0,2) ) ] * pnadc_df$deflt )

# preliminary survey design
pre_stratified <-
  svydesign(
    ids = ~ upa , 
    strata = ~ estrato , 
    weights = ~ v1031 , 
    data = pnadc_df ,
    nest = TRUE
  )
# warning: do not use `pre_stratified` in your analyses!
# you must use the `pnadc_design` object created below.

# post-stratification targets
df_pos <- data.frame( posest = unique( pnadc_df$posest ) , Freq = unique( pnadc_df$v1030 ) )

# final survey design object
pnadc_design <- postStratify( pre_stratified , ~ posest , df_pos )

# remove the `pnadc_df` data.frame object
# and the `pre_stratified` design before stratification
rm( pnadc_df , pre_stratified , df_pos )

# aplica convey
pnadc_design <- convey_prep( pnadc_design )
```
Vamos começar com a medida de desigualdade mais utilizada, o [índice de Gini](https://pt.wikipedia.org/wiki/Coeficiente_de_Gini). O Distrito Federal é o estado mais desigual do país. Ainda assim, os intervalos de confiança não permitem dizer que existam diferenças estatisticamente significativas entre muitos estados.
```{r gini_plot, echo=FALSE, message=FALSE, warning=FALSE }
# estima indices de gini
br_gini <- svyby( ~def_vd5002 , ~one , pnadc_design , svygini , na.rm = TRUE )
uf_gini <- svyby( ~def_vd5002 , ~uf_name , pnadc_design , svygini , na.rm = TRUE )

res1 <- list( br_gini , uf_gini )

# build result set
res1 <- lapply( res1 , function( x ) {
  this_est <- data.frame( x ) 
  colnames( this_est )[1] <- c( "area" )
  
  this_ci <- data.frame( confint( x ) )
  colnames( this_ci ) <- c( "ci_l" , "ci_u" ) 
  
  this_cv <- data.frame( cv( x ) )
  colnames( this_cv ) <- "cv"
  
  this_result <- cbind( set = names( x[1] ), this_est , this_ci , this_cv )
  rownames( this_result ) <- NULL
  
  if ( length( this_result$set ) == 1 & ( "one" %in% this_result$set ) ) this_result$area <- "Brasil"
  
  this_result
} )
res1 <- do.call( rbind , res1 )

# plotting
library(dplyr)
library(ggplot2)
library(gridExtra)
library(grid)
library(scales)
library(ggiraph)

# plot.order <- res1 %>% filter( set %in% c("one" , "uf_name")) %>% select(order)
# plot.order <- plot.order[,1]
# plot.order[-1] <- order( plot.order[-1] ) + 1

plot.order <- res1 %>% filter( set %in% c("one" , "uf_name")) %>% select( area , def_vd5002 )
plot.order <- plot.order %>% arrange( -def_vd5002 )
plot.order <- rbind( plot.order[ plot.order[ , "area" ] == "Brasil" , ] , plot.order[ plot.order[ , "area" ] != "Brasil" , ] )
plot.order <- plot.order[ , "area" ]

gini_cp <- 
  ggplot( res1 %>% filter( set %in% c("one" , "uf_name")), aes( area, def_vd5002 , group = area , color = area ) ) +
  geom_line( alpha = .3 ) + 
  geom_errorbar(aes(ymin=ci_l, ymax=ci_u), width=.1 , alpha = .5 ) +
  geom_point( size = 1) +
  scale_y_continuous( expand = c(0,0) ) +
  scale_x_discrete(limits= rev( plot.order ) ) +
  coord_flip( ylim=c(.3 , .72) ) +
  labs( x = NULL , y = "Índice de Gini", 
        title = "Índice de Gini da Renda Domiciliar Per Capita" , 
        subtitle ="Brasil e UFs, 2016.\nCom intervalo de confiança de 95%." ,
        caption = "Fonte: PNAD Contínua 2016. Microdados.") +
  # scale_color_brewer(type = "qual" , palette = "Dark2" , direction = 1 ) +
  guides(color = FALSE ) +
  # theme_dark() +
  theme( panel.background = element_blank() ,
         panel.grid.major.x = element_line( linetype = 2 , color = "lightgrey" , size = .2 ) ,
         # panel.grid.minor.x = element_blank() , 
         # panel.grid.minor.x = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         panel.grid.major.y = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         # axis.text.x = element_text(angle = 90, hjust = 1) ,
         plot.title = element_text(lineheight=.8, face="bold") ) 

gini_cp
# ggiraph( code = { print( gini_cp ) } , zoom_max = 1 , width = 1 , tooltip_opacity = .7 , width_svg = 8, height_svg= 5 )
```

A outra coisa clara neste gráfico é que Santa Catarina é o estado menos desigual, embora a diferença em relação ao segundo menos desigual, Mato Grosso, não seja estatisticamente significativa.

No entanto, é importante lembrar que o índice de Gini tem seus problemas^[Sobre os potenciais problemas do índice de Gini, sugiro [esse artigo](https://oxfamblogs.org/fp2p/on-inequality-lets-do-the-palma-because-the-gini-is-so-last-century/).]. Por conta disso, vamos explorar algumas alternativas, como a razão de Palma e o índice de Zenga.

##### Razão de Palma

A [razão de Palma](http://www.un.org/esa/desa/papers/2015/wp143_2015.pdf) é bastante intuitiva. Basicamente, este índice é a razão entre as rendas dos 10% mais ricos sobre a dos 40% mais pobres. Dessa forma, ele consegue ser mais sensível aos extremos da distribuição de renda do que o índice de Gini, por exemplo. Vejamos os resultados para o Brasil.
```{r palma_plot, echo=FALSE, message=FALSE, warning=FALSE }
# estima indices de palma
br_palma <- svyby( ~def_vd5002 , ~one , pnadc_design , svyqsr , alpha2 = .1 , alpha1 = .4 , na.rm = TRUE )
cp_palma <- svyby( ~def_vd5002 , ~uf_name , pnadc_design , svyqsr , alpha2 = .1 , alpha1 = .4 , na.rm = TRUE )

res2 <- list( br_palma , cp_palma )

# build result set
res2 <- lapply( res2 , function( x ) {
  this_est <- data.frame( x ) 
  colnames( this_est )[1] <- c( "area" )
  
  this_ci <- data.frame( confint( x ) )
  colnames( this_ci ) <- c( "ci_l" , "ci_u" ) 
  
  this_cv <- data.frame( cv( x ) )
  colnames( this_cv ) <- "cv"
  
  this_result <- cbind( set = names( x[1] ), this_est , this_ci , this_cv )
  rownames( this_result ) <- NULL
  
  if ( length( this_result$set ) == 1 & ( "one" %in% this_result$set ) ) this_result$area <- "Brasil"
  
  this_result
} )
res2 <- do.call( rbind , res2 )

# plotting

# plot.order <- res2 %>% filter( set %in% c("one" , "uf_name")) %>% select(order)
# plot.order <- plot.order[,1]
# plot.order[-1] <- order( plot.order[-1] ) + 1

plot.order <- res2 %>% filter( set %in% c("one" , "uf_name")) %>% select( area , def_vd5002 )
plot.order <- plot.order %>% arrange( -def_vd5002 )
plot.order <- rbind( plot.order[ plot.order[ , "area" ] == "Brasil" , ] , plot.order[ plot.order[ , "area" ] != "Brasil" , ] )
plot.order <- plot.order[ , "area" ]

palma_cp <- 
  ggplot( res2 %>% filter( set %in% c("one" , "uf_name")), aes( area, def_vd5002 , group = area , color = area ) ) +
  geom_line( alpha = .3 ) + 
  geom_errorbar(aes(ymin=ci_l, ymax=ci_u), width=.1 , alpha = .5 ) +
  geom_point( size = 1) +
  scale_y_continuous(  expand = c(0,.5) , breaks = seq(4,20,2) ) +
  scale_x_discrete(limits= rev( plot.order ) ) +
  coord_flip( ylim=c( 4 , 19) ) +
  labs( x = NULL , y = "Razão de Palma", 
        title = "Razão de Palma da Renda Domiciliar Per Capita" , 
        subtitle ="Brasil e UFs, 2016.\nCom intervalo de confiança de 95%." ,
        caption = "Fonte: PNAD Contínua 2016. Microdados.") +
  # scale_color_brewer(type = "qual" , palette = "Dark2" , direction = 1 ) +
  guides(color = FALSE ) +
  # theme_dark() +
  theme( panel.background = element_blank() ,
         panel.grid.major.x = element_line( linetype = 2 , color = "lightgrey" , size = .2 ) ,
         # panel.grid.minor.x = element_blank() , 
         # panel.grid.minor.x = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         panel.grid.major.y = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         # axis.text.x = element_text(angle = 90, hjust = 1) ,
         plot.title = element_text(lineheight=.8, face="bold") ) 

palma_cp
# ggiraph( code = { print( palma_cp ) } , zoom_max = 1 , width = 1 , tooltip_opacity = .7 , width_svg = 8, height_svg= 5 )
```

Bom, o ordenamento muda um pouco. Embora o DF continue sendo o mais desigual, Pernambuco cai algumas posições. Isso se deve ao fato deste índice ser um pouco mais sensível aos extremos da distribuição.  
Entretanto, este índice também sofre algumas críticas. De fato, ele não atende muitos axiomas esperados dos índices de desigualdade. Com isso em mente, incluiremos mais um índice.

##### Índice de Zenga

O [índice de Zenga](https://link.springer.com/article/10.1007/s10687-013-0177-2) é uma medida relativamente recente. Ele satisfaz os mesmos axiomas que o índice de Gini, mas "pesa" todas as observações igualmente, mantendo a mesma sensibilidade ao longo de toda a distribuição de renda.
```{r zenga_plot, echo=FALSE, message=FALSE, warning=FALSE }
# estima indices de zenga
br_zenga <- svyby( ~def_vd5002 , ~one , pnadc_design , svyzenga , na.rm = TRUE )
cp_zenga <- svyby( ~def_vd5002 , ~uf_name , pnadc_design , svyzenga , na.rm = TRUE )

res3 <- list( br_zenga , cp_zenga )

# build result set
res3 <- lapply( res3 , function( x ) {
  this_est <- data.frame( x ) 
  colnames( this_est )[1] <- c( "area" )
  
  this_ci <- data.frame( confint( x ) )
  colnames( this_ci ) <- c( "ci_l" , "ci_u" ) 
  
  this_cv <- data.frame( cv( x ) )
  colnames( this_cv ) <- "cv"
  
  this_result <- cbind( set = names( x[1] ), this_est , this_ci , this_cv )
  rownames( this_result ) <- NULL
  
  if ( length( this_result$set ) == 1 & ( "one" %in% this_result$set ) ) this_result$area <- "Brasil"
  
  this_result
} )
res3 <- do.call( rbind , res3 )

# plotting

# plot.order <- res3 %>% filter( set %in% c("one" , "uf_name")) %>% select(order)
# plot.order <- plot.order[,1]
# plot.order[-1] <- order( plot.order[-1] ) + 1

plot.order <- res3 %>% filter( set %in% c("one" , "uf_name")) %>% select( area , def_vd5002 )
plot.order <- plot.order %>% arrange( -def_vd5002 )
plot.order <- rbind( plot.order[ plot.order[ , "area" ] == "Brasil" , ] , plot.order[ plot.order[ , "area" ] != "Brasil" , ] )
plot.order <- plot.order[ , "area" ]

zenga_cp <- 
  ggplot( res3 %>% filter( set %in% c("one" , "uf_name")), aes( area, def_vd5002 , group = area , color = area ) ) +
  geom_line( alpha = .3 ) + 
  geom_errorbar(aes(ymin=ci_l, ymax=ci_u), width=.1 , alpha = .5 ) +
  geom_point( size = 1) +
  scale_y_continuous(  expand = c(.05,.05) , breaks = seq(0 , 1 , .05) ) +
  scale_x_discrete(limits= rev( plot.order ) ) +
  coord_flip( ylim=c( .7 , .9) ) +
  labs( x = NULL , y = "Índice de Zenga", 
        title = "Índice de Zenga da Renda Domiciliar Per Capita" , 
        subtitle ="Brasil e UFs, 2016.\nCom intervalo de confiança de 95%." ,
        caption = "Fonte: PNAD Contínua 2016. Microdados.") +
  # scale_color_brewer(type = "qual" , palette = "Dark2" , direction = 1 ) +
  guides(color = FALSE ) +
  # theme_dark() +
  theme( panel.background = element_blank() ,
         panel.grid.major.x = element_line( linetype = 2 , color = "lightgrey" , size = .2 ) ,
         # panel.grid.minor.x = element_blank() , 
         # panel.grid.minor.x = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         panel.grid.major.y = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         # axis.text.x = element_text(angle = 90, hjust = 1) ,
         plot.title = element_text(lineheight=.8, face="bold") ) 

zenga_cp
# ggiraph( code = { print( zenga_cp ) } , zoom_max = 1 , width = 1 , tooltip_opacity = .7 , width_svg = 8, height_svg= 5 )
```

O gráfico revela uma distribuição similar ao da razão de Palma. 
Em todos os casos, o Distrito Federal apresenta a maior desigualdade.

#### Pobreza

Olha a desigualdade não é suficiente para analisar a condição de vida na sociedade. Afinal, uma sociedade A pode ser mais desigual que a sociedade B, tendo um nível de pobreza inferior.  
Neste exercício, consideramos a linha de pobreza equivalente a 1/4 do salário mínimo em julho de 2016. Ou seja, R$ 220,00. De fato, esse valor pode ser considerado como uma linha de extrema pobreza.

Vejamos, então, as estatísticas de pobreza no Brasil.

##### Taxa de Pobreza

O indicador mais utilizado quando se discute pobreza é a taxa de pobreza. Basicamente, essa medida é a proporção de pessoas pobres em determinada população.  
```{r fgt0_plot, echo=FALSE, message=FALSE, warning=FALSE }
# estima fgt0
br_fgt0 <- svyby( ~def_vd5002 , ~one , pnadc_design , svyfgt , g = 0 , abs_thresh = 220 , na.rm = TRUE )
cp_fgt0 <- svyby( ~def_vd5002 , ~uf_name , pnadc_design , svyfgt , g = 0 , abs_thresh = 220 , na.rm = TRUE )

# res4 <- list( br_fgt0 , rg_fgt0 , uf_fgt0 , cp_fgt0 )
res4 <- list( br_fgt0 , cp_fgt0 )

# build result set
res4 <- lapply( res4 , function( x ) {
  this_est <- data.frame( x ) 
  colnames( this_est )[1] <- c( "area" )
  
  this_ci <- data.frame( confint( x ) )
  colnames( this_ci ) <- c( "ci_l" , "ci_u" ) 
  
  this_cv <- data.frame( cv( x ) )
  colnames( this_cv ) <- "cv"
  
  this_result <- cbind( set = names( x[1] ), this_est , this_ci , this_cv )
  rownames( this_result ) <- NULL
  
  if ( length( this_result$set ) == 1 & ( "one" %in% this_result$set ) ) this_result$area <- "Brasil"
  
  this_result
} )
res4 <- do.call( rbind , res4 )

# plotting

# plot.order <- res3 %>% filter( set %in% c("one" , "uf_name")) %>% select(order)
# plot.order <- plot.order[,1]
# plot.order[-1] <- order( plot.order[-1] ) + 1

plot.order <- res4 %>% filter( set %in% c("one" , "uf_name")) %>% select( area , def_vd5002 )
plot.order <- plot.order %>% arrange( -def_vd5002 )
plot.order <- rbind( plot.order[ plot.order[ , "area" ] == "Brasil" , ] , plot.order[ plot.order[ , "area" ] != "Brasil" , ] )
plot.order <- plot.order[ , "area" ]

fgt0_cp <- 
  ggplot( res4 %>% filter( set %in% c("one" , "uf_name")), aes( area, def_vd5002 , group = area , color = area ) ) +
  geom_line( alpha = .3 ) + 
  geom_errorbar(aes(ymin=ci_l, ymax=ci_u), width=.1 , alpha = .5 ) +
  geom_point( size = 1) +
  scale_y_continuous( labels = percent , breaks = seq(0 , 1 , .05 ) ) +
  scale_x_discrete(limits= rev( plot.order ) ) +
  coord_flip( ylim=c( 0 , .4) ) +
  labs( x = NULL , y = "FGT(0)", 
        title = "Taxa de Pobreza" , 
        subtitle ="Brasil e UFs, 2016. Linha de Pobreza: R$ 220,00.\nCom intervalo de confiança de 95%." ,
        caption = "Fonte: PNAD Contínua 2016. Microdados.") +
  # scale_color_brewer(type = "qual" , palette = "Dark2" , direction = 1 ) +
  guides(color = FALSE ) +
  # theme_dark() +
  theme( panel.background = element_blank() ,
         panel.grid.major.x = element_line( linetype = 2 , color = "lightgrey" , size = .2 ) ,
         # panel.grid.minor.x = element_blank() , 
         # panel.grid.minor.x = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         panel.grid.major.y = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         # axis.text.x = element_text(angle = 90, hjust = 1) ,
         plot.title = element_text(lineheight=.8, face="bold") ) 

fgt0_cp
# ggiraph( code = { print( zenga_cp ) } , zoom_max = 1 , width = 1 , tooltip_opacity = .7 , width_svg = 8, height_svg= 5 )
```
As estimativas revelam que, na prática, existe um *empate* entre a proporção de pessoas pobres no Acre e Amazonas. Olhando o resto da lista, pode-se ver que os estados do Norte e Nordeste tendem a "liderar" neste ranking.

##### Hiato de Pobreza

Em que pese a sua simplicidade, a taxa de pobreza tem um problema: a pessoa que tem R\$ 1 a menos da linha de pobreza recebe o mesmo peso da pessoa que tem R\$ 200. Desta forma, perde muito da informação a respeito da intensidade da pobreza.  
A classe *Foster-Greer-Thorbecke (FGT)* de índices de pobreza apresenta como solução o *Hiato de Pobreza*. Este índice pondera cada obervação pela distância em relação à linha de pobreza.

```{r fgt1_plot, echo=FALSE, message=FALSE, warning=FALSE }
# estima fgt1
br_fgt1 <- svyby( ~def_vd5002 , ~one , pnadc_design , svyfgt , g = 1 , abs_thresh = 220 , na.rm = TRUE )
cp_fgt1 <- svyby( ~def_vd5002 , ~uf_name , pnadc_design , svyfgt , g = 1 , abs_thresh = 220 , na.rm = TRUE )

res5 <- list( br_fgt1 , cp_fgt1 )

# build result set
res5 <- lapply( res5 , function( x ) {
  this_est <- data.frame( x ) 
  colnames( this_est )[1] <- c( "area" )
  
  this_ci <- data.frame( confint( x ) )
  colnames( this_ci ) <- c( "ci_l" , "ci_u" ) 
  
  this_cv <- data.frame( cv( x ) )
  colnames( this_cv ) <- "cv"
  
  this_result <- cbind( set = names( x[1] ), this_est , this_ci , this_cv )
  rownames( this_result ) <- NULL
  
  if ( length( this_result$set ) == 1 & ( "one" %in% this_result$set ) ) this_result$area <- "Brasil"
  
  this_result
} )
res5 <- do.call( rbind , res5 )

# plotting

# plot.order <- res3 %>% filter( set %in% c("one" , "uf_name")) %>% select(order)
# plot.order <- plot.order[,1]
# plot.order[-1] <- order( plot.order[-1] ) + 1

plot.order <- res5 %>% filter( set %in% c("one" , "uf_name")) %>% select( area , def_vd5002 )
plot.order <- plot.order %>% arrange( -def_vd5002 )
plot.order <- rbind( plot.order[ plot.order[ , "area" ] == "Brasil" , ] , plot.order[ plot.order[ , "area" ] != "Brasil" , ] )
plot.order <- plot.order[ , "area" ]

fgt1_cp <- 
  ggplot( res5 %>% filter( set %in% c("one" , "uf_name")), aes( area, def_vd5002 , group = area , color = area ) ) +
  geom_line( alpha = .3 ) + 
  geom_errorbar(aes(ymin=ci_l, ymax=ci_u), width=.1 , alpha = .5 ) +
  geom_point( size = 1) +
  scale_y_continuous( labels = percent , breaks = seq(0 , 1 , .05 ) ) +
  scale_x_discrete(limits= rev( plot.order ) ) +
  coord_flip( ylim=c( 0 , .2) ) +
  labs( x = NULL , y = "FGT(1)", 
        title = "Índice do Hiato de Pobreza" , 
        subtitle ="Brasil e UFs, 2016. Linha de Pobreza: R$ 220,00.\nCom intervalo de confiança de 95%." ,
        caption = "Fonte: PNAD Contínua 2016. Microdados.") +
  # scale_color_brewer(type = "qual" , palette = "Dark2" , direction = 1 ) +
  guides(color = FALSE ) +
  # theme_dark() +
  theme( panel.background = element_blank() ,
         panel.grid.major.x = element_line( linetype = 2 , color = "lightgrey" , size = .2 ) ,
         # panel.grid.minor.x = element_blank() , 
         # panel.grid.minor.x = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         panel.grid.major.y = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         # axis.text.x = element_text(angle = 90, hjust = 1) ,
         plot.title = element_text(lineheight=.8, face="bold") ) 

fgt1_cp
# ggiraph( code = { print( zenga_cp ) } , zoom_max = 1 , width = 1 , tooltip_opacity = .7 , width_svg = 8, height_svg= 5 )
```

Aqui, o ordenamento muda um pouco. Embora Maranhão continue liderando, o Amazonas cai algumas posições. Comparando Amazonas e Acre, Isto indica que, embora a *extensão* da pobreza entre as duas populações seja praticamente idêntica, a pobreza no Acre é *mais intensa*. Em outras palavras: a renda domiciliar per capita entre as pessoas em situação de pobreza neste estado é inferior à do Amazonas.  
Isso tem impactos importantes quanto às políticas públicas. Por exemplo, um programa de transferência de renda exigiria, *proporcionalmente*, mais recursos no Acre do que no Amazonas.

##### Hiato Quadrático de Pobreza

Outro índice da classe FGT, o Hiato Quadrático de Pobreza incorpora a desigualdade de renda entre a população em situação de pobreza. Ao contrário do Hiato de Pobreza, a distância entre a renda de determinada observação e a linha de pobreza é elevada ao quadrado. Ou seja: os mais pobres recebem pesos ainda maiores no processo de ponderação.  

Isto implica que transferências regressivas de renda entre os pobres são penalizadas. Por exemplo, se a renda do indivíduo A, mais pobre, é transferida para o indivíduo B (menos pobre), o Hiato de Pobreza é o mesmo, mas o Hiato Quadrático é diferente.  

Isso também pode ser visto de outra maneira. Considerando a classe de *índices de Entropia Generalizada (GEI)*, uma classe de medidas de desigualdade, podemos reescrever o índice FGT(2) como uma função da Taxa de Pobreza, Hiato de Pobreza e do índice GEI(2) das insuficiências de renda. Assim, evidenciamos o efeito da desigualdade entre as rendas dos pobres sobre a estimativa do FGT(2). Matematicamente,

$$
FGT_{2}= \frac{FGT_1^2}{FGT_0} \cdot \bigg( 1 + 2 \cdot GEI_{2}^{*} \bigg) \text{ ,} 
$$

onde $GEI_{2}^{*}$ é o índice GEI($\epsilon$=2) das insuficiências de renda.

Vejamos os resultados dos estados brasileiras.
```{r fgt2_plot, echo=FALSE, message=FALSE, warning=FALSE }
# estima fgt2
br_fgt2 <- svyby( ~def_vd5002 , ~one , pnadc_design , svyfgt , g = 2 , abs_thresh = 220 , na.rm = TRUE )
cp_fgt2 <- svyby( ~def_vd5002 , ~uf_name , pnadc_design , svyfgt , g = 2 , abs_thresh = 220 , na.rm = TRUE )

res6 <- list( br_fgt2 , cp_fgt2 )

# build result set
res6 <- lapply( res6 , function( x ) {
  this_est <- data.frame( x ) 
  colnames( this_est )[1] <- c( "area" )
  
  this_ci <- data.frame( confint( x ) )
  colnames( this_ci ) <- c( "ci_l" , "ci_u" ) 
  
  this_cv <- data.frame( cv( x ) )
  colnames( this_cv ) <- "cv"
  
  this_result <- cbind( set = names( x[1] ), this_est , this_ci , this_cv )
  rownames( this_result ) <- NULL
  
  if ( length( this_result$set ) == 1 & ( "one" %in% this_result$set ) ) this_result$area <- "Brasil"
  
  this_result
} )
res6 <- do.call( rbind , res6 )

# plotting

# plot.order <- res3 %>% filter( set %in% c("one" , "uf_name")) %>% select(order)
# plot.order <- plot.order[,1]
# plot.order[-1] <- order( plot.order[-1] ) + 1

plot.order <- res6 %>% filter( set %in% c("one" , "uf_name")) %>% select( area , def_vd5002 )
plot.order <- plot.order %>% arrange( -def_vd5002 )
plot.order <- rbind( plot.order[ plot.order[ , "area" ] == "Brasil" , ] , plot.order[ plot.order[ , "area" ] != "Brasil" , ] )
plot.order <- plot.order[ , "area" ]

fgt2_cp <- 
  ggplot( res6 %>% filter( set %in% c("one" , "uf_name")), aes( area, def_vd5002 , group = area , color = area ) ) +
  geom_line( alpha = .3 ) + 
  geom_errorbar(aes(ymin=ci_l, ymax=ci_u), width=.1 , alpha = .5 ) +
  geom_point( size = 1) +
  scale_y_continuous( labels = percent , breaks = seq(0 , 1 , .05 ) ) +
  scale_x_discrete(limits= rev( plot.order ) ) +
  coord_flip( ylim=c( 0 , .2) ) +
  labs( x = NULL , y = "FGT(2)", 
        title = "Índice do Hiato Quadrático de Pobreza" , 
        subtitle ="Brasil e UFs, 2016. Linha de Pobreza: R$ 220,00.\nCom intervalo de confiança de 95%." ,
        caption = "Fonte: PNAD Contínua 2016. Microdados.") +
  # scale_color_brewer(type = "qual" , palette = "Dark2" , direction = 1 ) +
  guides(color = FALSE ) +
  # theme_dark() +
  theme( panel.background = element_blank() ,
         panel.grid.major.x = element_line( linetype = 2 , color = "lightgrey" , size = .2 ) ,
         # panel.grid.minor.x = element_blank() , 
         # panel.grid.minor.x = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         panel.grid.major.y = element_line( linetype = 3 , color = "lightgrey" , size = .2 ) ,
         # axis.text.x = element_text(angle = 90, hjust = 1) ,
         plot.title = element_text(lineheight=.8, face="bold") ) 

fgt2_cp
# ggiraph( code = { print( zenga_cp ) } , zoom_max = 1 , width = 1 , tooltip_opacity = .7 , width_svg = 8, height_svg= 5 )
```

De novo, Maranhão é o primeiro do ranking. Porém, o Amazonas se distancia bastante agora. O que isso quer dizer? Talvez a decomposição do índice pode nos ajudar a entender as diferenças nas estimativas do FGT(2) entre as populações.

```{r fgt2dec_table, echo=FALSE, message=FALSE, warning=FALSE }
# estima fgt2
br_fgt2_dec <- svyby( ~def_vd5002 , ~one , pnadc_design , svyfgtdec , g = 2 , abs_thresh = 220 , na.rm = TRUE )
cp_fgt2_dec <- svyby( ~def_vd5002 , ~uf_name , pnadc_design , svyfgtdec , g = 2 , abs_thresh = 220 , na.rm = TRUE )

res7 <- list( br_fgt2_dec , cp_fgt2_dec )

# build result set
res7 <- lapply( res7 , function( x ) {
  this_est <- data.frame( x ) 
  colnames( this_est )[1] <- c( "area" )
  
  # this_ci <- data.frame( confint( x ) )
  # colnames( this_ci ) <- paste( c( "fgt2" , "fgt0" , "fgt1" , "igr" , "gei(poor;epsilon=2)" ) , c( "ci_l" , "ci_u" ) , sep = "_" ) 
  this_cv <- data.frame( cv( x ) )
  colnames( this_cv ) <- paste( "cv" , c( "fgt2" , "fgt0" , "fgt1" , "igr" , "gei(poor;epsilon=2)" ) , sep = "_" )
  
  this_result <- cbind( set = names( x[1] ), this_est , this_cv )
  rownames( this_result ) <- NULL
  
  if ( length( this_result$set ) == 1 & ( "one" %in% this_result$set ) ) this_result$area <- "Brasil"
  
  this_result
} )
res7 <- do.call( rbind , res7 )

# get rid of igr
res7 <- res7[ , !grepl( "igr" , colnames( res7 ) ) ]

# table

table_res7 <- res7 %>% filter( set %in% c("one" , "uf_name"))
table_res7 <- table_res7 %>% arrange( -fgt2 )
table_res7 <- rbind( table_res7[ table_res7[ , "area" ] == "Brasil" , ] , table_res7[ table_res7[ , "area" ] != "Brasil" , ] )
table_res7 <- table_res7[ , 2:6 ]

tb7_names <- c( "Área" , "FGT(2)" , "FGT(0)" , "FGT(1)" , "GEI(2)" )

library(knitr)
kable( table_res7 , col.names = tb7_names , row.names = FALSE , digits = c( 3,3,3,3 ) )
```

No caso, ainda que o Amazonas apresente maior desigualdade no renda-linha de pobreza dos domicílios pobres, as diferenças na extensão e intensidade são os determinantes deste ordenamento. Isso implica que embora a desigualdade seja mais intensa no Amazonas, a população em situação de pobreza ainda está, em média, numa situação melhor que a do Maranhão.

### Concluindo

Embora ainda não tenhamos uma série suficientemente longa para compreender o impacto da crise sobre a pobreza e desigualdade no Brasil, já conseguimos observar a situação dos estados. Como a ideia aqui era só uma análise superficial, muita coisa ainda precisa ser explorada. Por exemplo: 

* Como os preços afetam a distribuição de renda?
* Como os rendimentos de programas sociais afetam a desigualdade e pobreza?

Acredito que ainda veremos mais sobre esses dados nos próximos meses.

E, como não poderia faltar, o vídeo de final de post!  
Já começaram a contagem regressiva para o carnaval?  
Nesse vídeo, Bruna Caram e Marina de la Riva interpretam *Bloco do Prazer*, de Moraes Moreira.

<!--html_preserve-->
<div style="position:relative;height:0;padding-bottom:56.21%"><iframe src="https://www.youtube.com/embed/aem2JxlRfGo?ecver=2" style="position:absolute;width:100%;height:100%;left:0" width="641" height="360" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe></div>
<!--/html_preserve-->
